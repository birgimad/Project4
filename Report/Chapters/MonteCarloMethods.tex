\section{Monte Carlo Method}


Monte Carlo methods are used for problems that can be described using probability distribution functions. This part will look at a brute force approach using two different probability distribution functions (PDF). With the probability distribution function the approach is to characterizing a problem using random numbers. Then getting a sum out of the function evaluated and considering the error made by finding the variance using this method.  

\subsection{Brute force method}
\label{subsec:MCMethod}
The brute force method uses the uniform probability distribution function. Where the stochastic variables are approximated using random numbers. Where the probability distribution function gives a probability or the relative frequency for the stochastic variables. The probability function $Prob(X)$ is found by \matref{eq:probfunc}, where $p(x)$ is the probability for one of the variables.
\begin{align}
Prob(a < X <b) = \int_a^b p(x) dx
\label{eq:probfunc}
\end{align}

The method consist in choosing a random number generator to make the stochastic values that goes in to the probability distribution function. This gives out the function values that make the integral sum. This also gives the possibility to generate the variance for estimating the error. 

The integral sum is made using \matref{eq:integralBF}. 

\begin{align}
I = \frac{1}{N}\sum_{i=1}^{N} f(x) \approx <f(x)>
\label{eq:integralBF}
\end{align}
 
The variance using \matref{eq:varianceBF}

\begin{align}
\sigma^2 = <x^2> - <x>^2
\label{eq:varianceBF} 
\end{align}

where $<x^2>$ is the expectation value that is found from the given PDF using \matref{eq:expvalue}. 

\begin{align}
<x^k> = \frac{1}{N}\sum_{i=1}^N x_i^k p(x)
\label{eq:expvalue}
\end{align} 

And for $<f(x)>$ it is found using \matref{eq:expf}

\begin{align}
<f(x)> = \frac{1}{N} \sum_{i=1}^{N} f(x)p(x) 
\label{eq:expf}
\end{align}

Part of the code is included below, and it shows the for loop that generates the integral. It does this by generating a random number for all of the 6-dimensions that exists. These variables it sends to the function that is integrated, returning a function value that goes in to the sum generating the end integral. This is done N times, preferably with N as high as possible. After the for loop the sum is multiplied with the Jacobi determinant giving the end integral. Also the variance is generated by the function value and used to produce the standard deviation sigma. 
  
\begin{lstlisting}
for (int i=0;i<N;i++){
            for (int j=0;j<6;j++){
                x[j] = - length +2*length*((double) rand() / (RAND_MAX)); //random numbers generated in the interval(-length,length)

                //cout<<x[j]<<endl;

            }

            fx = func(x[0],x[1],x[2],x[3],x[4],x[5]);
            Montec += fx;
            Montesqr += fx*fx;

       }

       double MC = Montec/((double) N );
       double Montesqr1= Montesqr/((double) N);
       double variance= Montesqr1-MC*MC;
       double volume = pow(length,6);
       cout << " Integral = " << jacobidet*MC << endl;
       cout << "sigma = " << jacobidet*sqrt(variance/ ((double) N)) << endl;

\end{lstlisting}


. 
